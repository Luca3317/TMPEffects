using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using TMPEffects.AutoParameters.Generator;
using TMPEffects.AutoParameters.TMPEffects.AutoParameters.Generator;
using TMPEffects.StringLibrary;

namespace TMPEffects.ParameterUtilityGenerator
{
    [Generator]
    public partial class TMPParameterBundleGenerator : ISourceGenerator
    {
        public const string DiagnosticId___ = "DebuggingError2";
        private static readonly LocalizableString Title___ = "Debugerror";
        private static readonly LocalizableString MessageFormat___ = "{0}";
        private const string Category___ = "Usage";
#pragma warning disable RS2008 // Enable analyzer release tracking
        internal static readonly DiagnosticDescriptor Rule___ = new DiagnosticDescriptor(DiagnosticId___, Title___,
            MessageFormat___, Category___, DiagnosticSeverity.Warning, isEnabledByDefault: true);
#pragma warning restore RS2008 // Enable analyzer release tracking

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new AttributeSyntaxReceiver("TMPParameterBundle"));
        }

        public void Execute(GeneratorExecutionContext context)
        {
            Location last = null;
            foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            {
                var model = context.Compilation.GetSemanticModel(syntaxTree);
                var classes = syntaxTree.GetRoot().DescendantNodes().OfType<TypeDeclarationSyntax>();

                foreach (var c in classes)
                {
                    last = c.GetLocation();
                }
            }

            AttributeSyntaxReceiver receiver = context.SyntaxReceiver as AttributeSyntaxReceiver;
            if (receiver == null) return;

            foreach (var typeDecl in receiver.TypeDeclarations)
            {
                SemanticModel model = context.Compilation.GetSemanticModel(typeDecl.SyntaxTree);
                ISymbol symbol = ModelExtensions.GetDeclaredSymbol(model, typeDecl);

                // Check whether attribute actually is the correct attribute
                bool isDecorated = false;
                foreach (var attributeData in symbol.GetAttributes())
                {
                    var attClass = attributeData.AttributeClass;

                    if (attClass.ToDisplayString() == Strings.TMPParameterBundleAttributeName)
                    {
                        isDecorated = true;
                        break;
                    }
                }

                if (!isDecorated) continue;

                INamedTypeSymbol typeSymbol = symbol as INamedTypeSymbol;
                try
                {
                    CreateTMPParameterBundle(context, model, typeDecl, typeSymbol);
                }
                catch (System.Exception ex)
                {
                    Diagnostic d = Diagnostic.Create(Rule___, typeDecl.GetLocation(),
                        "Failed to create TMPParameterBundle on " +
                        typeDecl.Identifier.Text + ". " +
                        "This is most likely a bug -- feel free to open an issue or a pull request with your fix on " +
                        "https://github.com/Luca3317/TMPEffects");
                    context.ReportDiagnostic(d);
                }
            }
        }

        private void CreateTMPParameterBundle(GeneratorExecutionContext context, SemanticModel model,
            TypeDeclarationSyntax typeDecl, INamedTypeSymbol symbol)
        {
            List<BundleFieldInfo> bundleFields = GetBundleFields(context, typeDecl, symbol);
            List<Utility.AutoParameterInfo> autoBundleFields = bundleFields.Select(ToAutoParameterInfo).ToList();

            string displayName = symbol.GetAttributes()
                .First(a => a.AttributeClass.ToDisplayString() == Strings.TMPParameterBundleAttributeName)
                .ConstructorArguments[0].Value as string;

            // Create ValidateDisplayName
            var validate = GetValidation(symbol, context, displayName, autoBundleFields);
            var parameters = GetParametersStruct(symbol, context, displayName, autoBundleFields);
            var getParameters = GetGetParameters(symbol, context, displayName, autoBundleFields);
            var createType = GetCreateType(symbol, context, displayName, autoBundleFields);

            string comment = $@"
// This file was auto-generated by AutoParameters.
// Changes to this file may cause incorrect behaviour and will be lost when the code is regenerated.
// To learn more about AutoParameters, read <see href=""https://tmpeffects.luca3317.dev/plugins/autoparameters.html"">HERE</see>.
// TODO Update link once docs updated
";
            
            typeDecl = typeDecl
                .WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>())
                .WithAttributeLists(SyntaxFactory.List<AttributeListSyntax>())
                .WithBaseList(null)
                .WithLeadingTrivia(SyntaxFactory.TriviaList())
                .WithTrailingTrivia(SyntaxFactory.TriviaList());
            typeDecl = typeDecl.AddMembers(validate, parameters, getParameters, createType);
            typeDecl = typeDecl.WithLeadingTrivia(SyntaxFactory.ParseLeadingTrivia(comment));
            

            // Prepare the namespace declaration
            var namespaceName = symbol.ContainingNamespace.ToDisplayString();
            var namespaceDecl = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(namespaceName))
                .AddMembers(typeDecl);

            var compilationUnit = SyntaxFactory.CompilationUnit();

            compilationUnit = compilationUnit.AddMembers(symbol.ContainingNamespace.IsGlobalNamespace
                ? (MemberDeclarationSyntax)typeDecl
                : namespaceDecl);

            compilationUnit =
                compilationUnit.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")));
            compilationUnit =
                compilationUnit.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("UnityEngine")));

            // Prepare and add source
            var source = SourceText.From(compilationUnit.NormalizeWhitespace().ToFullString(), Encoding.UTF8);
            context.AddSource($"{symbol.ToDisplayString()}.tmpbundle.g.cs", source);
        }

        // TODO prependprefix in other 2 methods
        // TODO Handle case passed in instance is null
        private MethodDeclarationSyntax GetCreateType(INamedTypeSymbol symbol, GeneratorExecutionContext context,
            string displayName,
            List<Utility.AutoParameterInfo> autoBundleFields)
        {
            string instanceName = symbol.Name + "Instance";
            string parameterName = "parameters";

            var paramList = SyntaxFactory.ParameterList()
                .AddParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier(instanceName))
                    .WithType(SyntaxFactory.ParseTypeName(symbol.Name)))
                .AddParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier(parameterName))
                    .WithType(SyntaxFactory.ParseTypeName(displayName + "Parameters")));

            // Prepare the method
            var method = SyntaxFactory
                .MethodDeclaration(SyntaxFactory.ParseTypeName(symbol.Name), "Create" + displayName)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .WithParameterList(paramList).WithReturnType(SyntaxFactory.ParseTypeName(symbol.Name));

            var createstatement = SyntaxFactory.ParseStatement($"var newInstance = new " + symbol.Name + "();");
            var assigments = autoBundleFields.Select(autoparam =>
                SyntaxFactory.ParseStatement(
                    $"newInstance.{autoparam.FieldName} = {parameterName}.{autoparam.FieldName} ?? {instanceName}.{autoparam.FieldName};"
                ));

            var statements = assigments.Prepend(createstatement).ToList();

            var stringType = context.Compilation.GetSpecialType(SpecialType.System_String);
            var present = Utility.ImplementsBundleCreateHook(displayName, symbol, stringType);

            // Call hook
            if (present)
            {
                var arguments = new List<ArgumentSyntax>()
                {
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName("ref newInstance")),
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName(instanceName)),
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName("parameters"))
                };
                var hc = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("Create_Hook"),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SeparatedList(arguments)));
                statements.Add(SyntaxFactory.ExpressionStatement(hc));
            }


            statements.Add(SyntaxFactory.ReturnStatement(SyntaxFactory.IdentifierName("newInstance")));

            return method.WithBody(SyntaxFactory.Block(statements));
        }

        private MethodDeclarationSyntax GetGetParameters(INamedTypeSymbol symbol, GeneratorExecutionContext context,
            string displayName, List<Utility.AutoParameterInfo> parameters)
        {
            var paramList = SyntaxFactory.ParameterList()
                .AddParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier("parameters"))
                    .WithType(SyntaxFactory.ParseTypeName("System.Collections.Generic.IDictionary<string, string>")))
                .AddParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier("keywords"))
                    .WithType(SyntaxFactory.ParseTypeName(Strings.ITMPKeywordDatabaseName))
                    .WithDefault(
                        SyntaxFactory.EqualsValueClause(
                            SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression))))
                .AddParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier("prefix"))
                    .WithType(SyntaxFactory.ParseTypeName("string"))
                    .WithDefault(
                        SyntaxFactory.EqualsValueClause(
                            SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression,
                                SyntaxFactory.Literal("")))));

            // Prepare the method
            var method = SyntaxFactory
                .MethodDeclaration(SyntaxFactory.ParseTypeName("void"), "Get" + displayName + "Parameters")
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .WithParameterList(paramList).WithReturnType(SyntaxFactory.ParseTypeName(displayName + "Parameters"));

            // Prepare all statements
            var statements = new List<StatementSyntax>();

            var condition = SyntaxFactory.BinaryExpression(
                SyntaxKind.EqualsExpression, SyntaxFactory.IdentifierName("parameters"),
                SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression));

            var returnStatement = SyntaxFactory.ReturnStatement(SyntaxFactory.IdentifierName("d"));
            var ifStatement = SyntaxFactory.IfStatement(condition, returnStatement);

            statements.Add(SyntaxFactory.ParseStatement($"var d = new " + displayName + "Parameters();"));
            statements.Add(ifStatement);

            foreach (var param in parameters)
            {
                var setParameterSyntax = Utility.GetSetParameterSyntax("parameters", "d", param,
                    "keywords", "prefix");
                if (setParameterSyntax != null) statements.Add(setParameterSyntax);
            }

            var stringType = context.Compilation.GetSpecialType(SpecialType.System_String);
            var present = Utility.ImplementsBundleGetParametersHook(symbol, stringType);

            // Call hook
            if (present)
            {
                var arguments = new List<ArgumentSyntax>()
                {
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName("parameters")),
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName("keywords")),
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName("prefix"))
                };
                var hc = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("GetParameters_Hook"),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SeparatedList(arguments)));
                statements.Add(SyntaxFactory.ExpressionStatement(hc));
            }

            statements.Add(returnStatement);

            // Add statements to method body
            return method.WithBody(SyntaxFactory.Block(statements));
        }


        private StructDeclarationSyntax GetParametersStruct(INamedTypeSymbol symbol, GeneratorExecutionContext context,
            string displayName, List<Utility.AutoParameterInfo> autoBundleFields)
        {
            MemberDeclarationSyntax[] members = autoBundleFields.Select(autoparam =>
                SyntaxFactory.FieldDeclaration(
                        SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.ParseTypeName(
                                    autoparam.IsArray
                                        ? autoparam.ArraySymbol.ToDisplayString()
                                        : autoparam.TypeString +
                                          // ensure you can assign null to it
                                          (Utility.IsNullable(autoparam.TypeSymbol) ? "" : "?")))
                            .AddVariables(SyntaxFactory.VariableDeclarator(autoparam.FieldName)))
                    .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))).ToArray<MemberDeclarationSyntax>();

            return SyntaxFactory.StructDeclaration(displayName + "Parameters")
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .WithMembers(SyntaxFactory.List(members))
                .WithOpenBraceToken(SyntaxFactory.Token(SyntaxKind.OpenBraceToken))
                .WithCloseBraceToken(SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
        }

        private MethodDeclarationSyntax GetValidation(INamedTypeSymbol symbol, GeneratorExecutionContext context,
            string displayName, List<Utility.AutoParameterInfo> parameters)
        {
            // Prepare the parameters
            var paramList = SyntaxFactory.ParameterList()
                .AddParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier("parameters"))
                    .WithType(SyntaxFactory.ParseTypeName("System.Collections.Generic.IDictionary<string, string>")))
                .AddParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier("keywords"))
                    .WithType(SyntaxFactory.ParseTypeName(Strings.ITMPKeywordDatabaseName))
                    .WithDefault(
                        SyntaxFactory.EqualsValueClause(
                            SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression))))
                .AddParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier("prefix"))
                    .WithType(SyntaxFactory.ParseTypeName("string"))
                    .WithDefault(
                        SyntaxFactory.EqualsValueClause(
                            SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression,
                                SyntaxFactory.Literal("")))));

            // Prepare the method
            var method = SyntaxFactory
                .MethodDeclaration(SyntaxFactory.ParseTypeName("bool"), "Validate" + displayName + "Parameters")
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .WithParameterList(paramList);

            // Get all hookCandidates (potential hook methods)
            var stringSymbol = context.Compilation.GetSpecialType(SpecialType.System_String);
            bool present = Utility.ImplementsBundleValidateParametersHook(symbol, stringSymbol);

            // Prepare all statements
            var statements = new List<StatementSyntax>();

            // If there is a hook method, add its invocation
            if (present)
            {
                var arguments = new List<ArgumentSyntax>()
                {
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName("parameters")),
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName("keywords")),
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName("prefix"))
                };
                var hc = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("ValidateParameters_Hook"),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SeparatedList(arguments)));
                var negation = SyntaxFactory.PrefixUnaryExpression(SyntaxKind.LogicalNotExpression, hc);
                var hookReturnStatement =
                    SyntaxFactory.ReturnStatement(SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression));
                var hookIfStatement = SyntaxFactory.IfStatement(negation, hookReturnStatement);
                statements.Add(hookIfStatement);
            }

            // Return if parameters null
            var condition = SyntaxFactory.BinaryExpression(
                SyntaxKind.EqualsExpression, SyntaxFactory.IdentifierName("parameters"),
                SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression));
            var returnStatement = SyntaxFactory.ReturnStatement(
                SyntaxFactory.LiteralExpression(SyntaxKind.TrueLiteralExpression));
            var ifStatement = SyntaxFactory.IfStatement(condition, returnStatement);
            statements.Add(ifStatement);

            // Add all checks
            foreach (var param in parameters)
            {
                var validationSyntax = Utility.GetValidationSyntax("parameters", param, "keywords", "prefix");
                // TODO the line above will throw atm (or produce bad code at least)
                // Will have to rewrite the get x syntax code to just directly use the path as the path to keywords;
                // Not necessarily as path from a context
                if (validationSyntax != null) statements.Add(validationSyntax);
            }

            // return true if passed all checks
            returnStatement =
                SyntaxFactory.ReturnStatement(SyntaxFactory.LiteralExpression(SyntaxKind.TrueLiteralExpression));
            statements.Add(returnStatement);

            // Add statements to method body
            return method.WithBody(SyntaxFactory.Block(statements));
        }

        private List<BundleFieldInfo> GetBundleFields(GeneratorExecutionContext context, TypeDeclarationSyntax typeDecl,
            INamedTypeSymbol typeSymbol)
        {
            var fields = typeSymbol.GetMembers().OfType<IFieldSymbol>();
            List<BundleFieldInfo> bundleFields = new List<BundleFieldInfo>();
            foreach (var field in fields)
            {
                if (TryGetBundleFieldInfo(field, out var info))
                    bundleFields.Add(info);
            }

            return bundleFields;
        }

        private static bool IsDecoratedAsBundleField(IFieldSymbol symbol, out AttributeData attData)
        {
            var attributes = symbol.GetAttributes();
            foreach (var attribute in attributes)
            {
                var baseClass = attribute?.AttributeClass;
                while (baseClass != null)
                {
                    if (baseClass.ToDisplayString() == Strings.TMPParameterBundleFieldAttributeName)
                    {
                        attData = attribute;
                        return true;
                    }

                    baseClass = baseClass.BaseType;
                }
            }

            attData = null;
            return false;
        }

        public static bool TryGetBundleFieldInfo(IFieldSymbol symbol, out BundleFieldInfo info)
        {
            info = new BundleFieldInfo();

            if (!IsDecoratedAsBundleField(symbol, out var attData)) return false;

            ITypeSymbol fitType;
            if (symbol.Type is IArrayTypeSymbol arr)
            {
                info.IsArray = true;
                info.ArrayTypeSymbol = arr;
                if (!Utility.TryGetClosestFitAutoParamType(arr.ElementType, out fitType)) return false;
            }
            else
            {
                info.IsArray = false;
                if (!Utility.TryGetClosestFitAutoParamType(symbol.Type, out fitType)) return false;
            }

            // Parse name & aliases
            var arguments = attData.ConstructorArguments.SelectMany(tc =>
                    tc.Kind == TypedConstantKind.Array ? tc.Values.ToArray() : new TypedConstant[] { tc })
                .Select(val => val.Value as string);

            info.AliasesWithName = arguments.ToArray();
            info.FirstAlias = info.AliasesWithName.First();
            info.Aliases = info.AliasesWithName.Skip(1).ToArray();

            info.TypeSymbol = fitType;
            info.TypeName = fitType.ToDisplayString();

            // We can reuse the auto parameter function here since
            // a bundle field is valid if its a auto parameter
            info.BuiltIn = Utility.IsBuiltInAutoParameter(info.TypeSymbol);

            if (info.BuiltIn)
            {
                string str;
                Strings.TypeStringToDisplayString(fitType, out str);
                info.DisplayNameString = str;
            }
            else
            {
                var attrs = info.TypeSymbol.GetAttributes();
                info.DisplayNameString = attrs
                    .First(a => a.AttributeClass.ToDisplayString() == Strings.TMPParameterTypeAttributeName)
                    .ConstructorArguments[0].Value as string;
            }


            info.FieldSymbol = symbol;
            info.FieldName = symbol.Name;

            return true;
        }

        private Utility.AutoParameterInfo ToAutoParameterInfo(BundleFieldInfo bfi)
        {
            Utility.AutoParameterInfo info = new Utility.AutoParameterInfo();
            info.TypeSymbol = bfi.TypeSymbol;
            info.FieldSymbol = bfi.FieldSymbol;
            info.FieldName = bfi.FieldName;
            info.TypeString = bfi.TypeName;
            info.Aliases = bfi.Aliases;
            info.FirstAlias = bfi.FirstAlias;
            info.AliasesWithName = bfi.AliasesWithName;
            info.DisplayNameString = bfi.DisplayNameString;

            info.specifiesRequirement = false;
            info.required = false;

            info.IsArray = bfi.IsArray;
            info.ArraySymbol = bfi.ArrayTypeSymbol;
            info.BuiltIn = bfi.BuiltIn;

            return info;
        }

        // TODO Theres not much point in having this, its
        // essentially the exact same as autoparameterinfo
        // instead make some "GetAutoParameterInfoFromBundleField"
        // or smth like that
        public struct BundleFieldInfo
        {
            public IFieldSymbol FieldSymbol;
            public ITypeSymbol TypeSymbol;
            public string TypeName;
            public string FieldName;
            public string FirstAlias;
            public string[] Aliases;
            public string[] AliasesWithName;

            public string DisplayNameString;

            public bool IsArray;
            public IArrayTypeSymbol ArrayTypeSymbol;

            public bool BuiltIn;
        }
    }
}