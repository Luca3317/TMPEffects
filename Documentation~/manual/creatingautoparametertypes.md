<link rel="stylesheet" type="text/css" href="../styles.css">

# Creating AutoParameter types
You can create your own parameter types that work in conjunction with AutoParameters.

## Decorating the type
Creating your own types is easy; all you have to do is decorate your class (or interface) with the <mark class="markstyle">TMPParameterType</mark> attribute and implement a static method that parses a string to an instance of the expected type.

The <mark class="markstyle">TMPParameterType</mark> attribute takes three parameters; only one is required:

- string displayName: The naming used for your type in methods generated by AutoParameters.

In some cases, you may want your parameter type to be implemented differently for [SceneAnimations](tmpanimator_sceneanimations.md) v. "normal" animations stored on disk (or [SceneCommands](tmpwriter_scenecommands.md) v. commands respectively).  
You can decorate a shared base type and specify different types to be used in the different scenarios:

- Type diskType: The type that will be used for animations / commands stored on disk.
- Type sceneType: The type that will be used for SceneAnimations / SceneCommands.

There is a fourth optional parameter explained below.

## Parser method
Your decorated type must implement a static method of the form: <mark class="markstyle">public static partial bool StringTo\*DisplayName\*(string str, out \*YourType\* result, ITMPKeywordDatabase keywords)</mark>. There will be a code fix for this once you decorated the class.

This method is used by AutoParameters to parse tag parameters that are of your type.

### Example
Below is a full example of how to use the <mark class="markstyle">TMPParameterType</mark> attribute. The fourth parameter is explained below.

```csharp
[TMPParameterType("OffsetProvider", typeof(OffsetTypePowerEnum), typeof(SceneOffsetTypePowerEnum), true)]
public partial interface ITMPOffsetProvider
{
    // ...

    public static partial bool StringToOffsetProvider(string str, out ITMPOffsetProvider result,
        TMPEffects.Databases.ITMPKeywordDatabase keywords)
    {
        result = null;

        switch (str)
        {
            case "sidx":
            case "sindex":
            case "segmentindex":
                result = new OffsetTypePowerEnum(TMPParameterTypes.OffsetType.SegmentIndex);
                return true;

            case "idx":
            case "index":
                result = new OffsetTypePowerEnum(TMPParameterTypes.OffsetType.Index);
                return true;

            case "word":
            case "wordidx":
            case "wordindex":
                result = new OffsetTypePowerEnum(TMPParameterTypes.OffsetType.Word);
                return true;

            // further cases...
        }

        return false;
    }
}
```

## Keyword database support
If you want your type to have full keyword support like a built-in type would,
you may achieve this by setting the fourth parameter of your <mark class="markstyle">TMPParameterType</mark> attribute, <mark class="markstyle">generateKeywordDatabase</mark>, to <mark class="markstyle">true</mark>.  
Doing so will automatically update all built-in keyword database types (such as [TMPKeywordDatabase](../api/TMPeffects.Databases.TMPKeywordDatabase), [TMPSceneKeywordDatabase](../api/TMPeffects.Databases.TMPSceneKeywordDatabase) etc.) to support your type.

This is a bit involved: As the constructor that takes the fourth parameter is internal to TMPEffects (for good reason :wink:) you will need to make your type part of the TMPEffects assembly. You can do so using [Assembly Definition References](https://docs.unity3d.com/6000.0/Documentation/Manual/class-AssemblyDefinitionReferenceImporter.html).

Of course, you can alternatively just use custom keyword database implementations that support your types manually and then cast the <mark class="markstyle">ITMPKeywordDatabase</mark> within your string parsing method.